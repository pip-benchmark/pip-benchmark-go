package runner

import (
	"fmt"
	"io/ioutil"
	"time"

	ix "github.com/adam-lavrik/go-imath/ix"
	util "github.com/pip-benchmark/pip-benchmark-go/utilities"
)

type ReportGenerator struct {
	separatorLine string
	newLine       string

	configuration *ConfigurationManager
	results       *ResultsManager
	parameters    *ParametersManager
	benchmarks    *BenchmarksManager
	environment   *EnvironmentManager
}

func NewReportGenerator(configuration *ConfigurationManager,
	results *ResultsManager, parameters *ParametersManager,
	benchmarks *BenchmarksManager, environment *EnvironmentManager) *ReportGenerator {

	c := ReportGenerator{}
	c.configuration = configuration
	c.results = results
	c.parameters = parameters
	c.benchmarks = benchmarks
	c.environment = environment
	c.separatorLine = "***************************************************************\r\n"
	c.newLine = "\r\n"
	return &c
}

func (c *ReportGenerator) Generate() string {
	output := ""
	output += c.generateHeader()
	output += c.generateBenchmarkList()

	if len(c.results.All()) > 1 {
		output += c.generateMultipleResults()
	} else {
		output += c.generateSingleResult()
	}

	output += c.generateSystemInfo()
	output += c.generateSystemBenchmark()
	output += c.generateParameters()
	return output
}

func (c *ReportGenerator) SaveToFile(fileName string) {
	output := c.Generate()
	ioutil.WriteFile(fileName, []byte(output), 0777)
}

func (c *ReportGenerator) generateHeader() string {
	output := ""
	output += c.separatorLine
	output += c.newLine
	output += "             P E R F O R M A N C E    R E P O R T"
	output += c.newLine
	output += c.newLine
	output += "                 Generated by Pip.Benchmark"
	output += c.newLine
	output += fmt.Sprintf("                   at %s, %s",
		util.Formatter.FormatDate(time.Now()), util.Formatter.FormatTime(time.Now()))
	output += c.newLine
	output += c.separatorLine
	output += c.newLine
	return output
}

func (c *ReportGenerator) generateBenchmarkList() string {
	output := ""
	output += "Executed Benchmarks:"
	output += c.newLine
	index := 0
	for _, benchmark := range c.benchmarks.IsSelected() {
		index++
		output += fmt.Sprintf("  %d. %s.%s [%d%%]",
			index, benchmark.Suite().Name(), benchmark.Name(), benchmark.GetProportion(),
		)
		output += c.newLine
	}
	output += c.newLine
	return output
}

func (c *ReportGenerator) generateMultipleResults() string {
	output := ""
	output += "Benchmarking Results:"
	output += c.newLine

	results := c.results.All()
	var resultTable [][]string = make([][]string, 0)
	for index := 0; index < len(results)+2; index++ {
		resultTable = append(resultTable, []string{"", "", "", ""})
	}

	// Fill column headers
	resultTable[0][0] = "Benchmark"
	resultTable[0][1] = "Performance (tps)"
	resultTable[0][2] = "CPU Load (%)"
	resultTable[0][3] = "Memory Usage (Mb)"

	var columnSizes []int = []int{9, 17, 12, 17}

	for index := 0; index < len(results); index++ {
		resultTable[index+1][0] = results[index].Benchmarks[0].FullName()
		columnSizes[0] = ix.Max(len(resultTable[index+1][0]), columnSizes[0])

		resultTable[index+1][1] = util.Formatter.FormatNumber(
			results[index].PerformanceMeasurement.AverageValue, 2)
		columnSizes[1] = ix.Max(len(resultTable[index+1][1]), columnSizes[1])

		resultTable[index+1][2] = util.Formatter.FormatNumber(
			results[index].CpuLoadMeasurement.AverageValue, 2)
		columnSizes[2] = ix.Max(len(resultTable[index+1][2]), columnSizes[2])

		resultTable[index+1][3] = util.Formatter.FormatNumber(
			results[index].MemoryUsageMeasurement.AverageValue, 2)
		columnSizes[3] = ix.Max(len(resultTable[index+1][3]), columnSizes[3])
	}

	for rowIndex := 0; rowIndex < len(results)+1; rowIndex++ {
		// Draw upper line
		if rowIndex == 0 {
			output += "+"
			for columnIndex := 0; columnIndex < 4; columnIndex++ {
				output += util.Formatter.PadRight("", columnSizes[columnIndex], "-")
				output += "+"
			}
			output += c.newLine
		}

		// Draw content
		output += "|"
		output += util.Formatter.PadRight(resultTable[rowIndex][0], columnSizes[0], " ")
		output += "|"
		output += util.Formatter.PadLeft(resultTable[rowIndex][1], columnSizes[1], " ")
		output += "|"
		output += util.Formatter.PadLeft(resultTable[rowIndex][2], columnSizes[2], " ")
		output += "|"
		output += util.Formatter.PadLeft(resultTable[rowIndex][3], columnSizes[3], " ")
		output += "|"
		output += c.newLine

		// Draw bottom line
		output += "+"
		for columnIndex := 0; columnIndex < 4; columnIndex++ {
			output += util.Formatter.PadRight("", columnSizes[columnIndex], "-")
			output += "+"
		}
		output += c.newLine
	}

	output += c.newLine
	return output
}

func (c *ReportGenerator) generateSingleResult() string {
	output := ""

	if len(c.results.All()) == 0 {
		return output
	}

	result := c.results.All()[0]

	output += "Benchmarking Results:"
	output += c.newLine
	if c.configuration.GetMeasurementType() == Peak {
		output += "  Measurement Type: Peak Performance"
	} else {
		output += fmt.Sprintf("  Measurement Type: Nominal Performance at %d tps",
			c.configuration.GetNominalRate())
	}
	output += c.newLine

	startTime := result.StartTime
	output += fmt.Sprintf("  Start Time:   %s", util.Formatter.FormatTime(startTime))
	output += c.newLine
	endTime := result.StartTime.Add(result.ElapsedTime)
	output += fmt.Sprintf("  End Time:     %s", util.Formatter.FormatTime(endTime))
	output += c.newLine
	elapsedTime := result.ElapsedTime
	output += fmt.Sprintf("  Elapsed Time: %s", util.Formatter.FormatTimeSpan(elapsedTime.Milliseconds()))
	output += c.newLine
	output += fmt.Sprintf("  Min Performance (tps):     %s",
		util.Formatter.FormatNumber(result.PerformanceMeasurement.MinValue, 2))
	output += c.newLine
	output += fmt.Sprintf("  Average Performance (tps): %s",
		util.Formatter.FormatNumber(result.PerformanceMeasurement.AverageValue, 2))
	output += c.newLine
	output += fmt.Sprintf("  Max Performance (tps):     %s",
		util.Formatter.FormatNumber(result.PerformanceMeasurement.MaxValue, 2))
	output += c.newLine
	output += fmt.Sprintf("  Min CPU Load (%%):          %s",
		util.Formatter.FormatNumber(result.CpuLoadMeasurement.MinValue, 2))
	output += c.newLine
	output += fmt.Sprintf("  Average CPU Load (%%):      %s",
		util.Formatter.FormatNumber(result.CpuLoadMeasurement.AverageValue, 2))
	output += c.newLine
	output += fmt.Sprintf("  Max CPU Load (%%):          %s",
		util.Formatter.FormatNumber(result.CpuLoadMeasurement.MaxValue, 2))
	output += c.newLine
	output += fmt.Sprintf("  Min Memory Usage (Mb):     %s",
		util.Formatter.FormatNumber(result.MemoryUsageMeasurement.MinValue, 2))
	output += c.newLine
	output += fmt.Sprintf("  Average Memory Usage (Mb): %s",
		util.Formatter.FormatNumber(result.MemoryUsageMeasurement.AverageValue, 2))
	output += c.newLine
	output += fmt.Sprintf("  Max Memory Usage (Mb):     %s",
		util.Formatter.FormatNumber(result.MemoryUsageMeasurement.MaxValue, 2))
	output += c.newLine
	output += c.newLine

	return output
}

func (c *ReportGenerator) generateSystemInfo() string {
	output := ""
	output += "System Information:"
	output += c.newLine
	for prop, value := range c.environment.SystemInfo() {
		output += fmt.Sprintf("  %s: %s", prop, value)
		output += c.newLine
	}
	output += c.newLine
	return output
}

func (c *ReportGenerator) generateSystemBenchmark() string {
	output := ""
	output += "System Benchmarking:"
	output += c.newLine
	output += fmt.Sprintf("  CPU Performance (MFLOP/s): %s",
		util.Formatter.FormatNumber(c.environment.CpuMeasurement(), 2))
	output += c.newLine
	output += fmt.Sprintf("  Video Performance (GOP/s): %s",
		util.Formatter.FormatNumber(c.environment.VideoMeasurement(), 2))
	output += c.newLine
	output += fmt.Sprintf("  Disk Performance (MB/s):   %s",
		util.Formatter.FormatNumber(c.environment.DiskMeasurement(), 2))
	output += c.newLine
	output += c.newLine
	return output
}

func (c *ReportGenerator) generateParameters() string {
	output := ""
	output += "Parameters:"
	output += c.newLine
	for _, parameter := range c.parameters.All() {
		output += fmt.Sprintf("  %s=%s", parameter.Name(), parameter.Value())
		output += c.newLine
	}
	output += c.newLine
	return output
}
